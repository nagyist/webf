// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by <%= command %>

// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: implementation_imports
// ignore_for_file: library_private_types_in_public_api
// ignore_for_file: prefer_void_to_null

import 'package:webf/webf.dart';

<% _.forEach(enums, function(enumDef) { %>
<%= enumDef.definition %>

<% }); %>

abstract class <%= className %>Bindings extends WidgetElement {
  <%= className %>Bindings(super.context);

  <% _.forEach(properties?.props, function(prop, index) { %>
    <% var propName = _.camelCase(prop.name); %>
    <% if (shouldMakeNullable(prop)) { %>
  <%= generateReturnType(prop.type, propName) %>? get <%= propName %>;
    <% } else { %>
  <%= generateReturnType(prop.type, propName) %> get <%= propName %>;
    <% } %>
  set <%= propName %>(value);
  <% }); %>

  <% if (properties?.props.length > 0) { %>
  @override
  void initializeAttributes(Map<String, ElementAttributeProperty> attributes) {
    super.initializeAttributes(attributes);

    <% _.forEach(properties?.props, function(prop, index) { %>
      <% var attributeName = _.kebabCase(prop.name); %>
      <% var propName = _.camelCase(prop.name); %>
    attributes['<%= attributeName %>'] = ElementAttributeProperty(
      getter: () => <%= generateAttributeGetter(propName, prop.type, prop.optional) %>,
      setter: (value) => <%= generateAttributeSetter(propName, prop.type) %>,
      deleter: () => <%= generateAttributeDeleter(propName, prop.type, prop.optional) %>
    );
    <% }); %>
  }

  static StaticDefinedBindingPropertyMap <%= _.camelCase(className) %>Properties = {
    <% _.forEach(properties?.props, function(prop, index) { %>
      <% var propName = _.camelCase(prop.name); %>

    '<%= propName %>': StaticDefinedBindingProperty(
      getter: (element) => castToType<<%= className %>Bindings>(element).<%= propName %>,
      setter: (element, value) =>
      castToType<<%= className %>Bindings>(element).<%= propName %> = value,
    ),
    <% }); %>
  };

  @override
  List<StaticDefinedBindingPropertyMap> get properties => [
    ...super.properties,
    <%= _.camelCase(className) %>Properties,
  ];
  <% } %>

  <% if (properties?.methods.length > 0) { %>

  <% _.forEach(properties?.methods, function(method, index) { %>
    <% var methodName = _.camelCase(method.name); %>
  <%= generateReturnType(method.returnType) %> <%= methodName %>(List<dynamic> args);
  <% }) %>

  static StaticDefinedSyncBindingObjectMethodMap <%= _.camelCase(className) %>Methods = {
    <% _.forEach(properties?.methods, function(method, index) { %>
      <% var methodName = method.name; %>
    '<%= methodName %>': StaticDefinedSyncBindingObjectMethod(
      call: (element, args) {
        return castToType<<%= className %>Bindings>(element).<%= methodName %>(args);
      },
    ),
    <% }); %>
  };

  @override
  List<StaticDefinedSyncBindingObjectMethodMap> get methods => [
    ...super.methods,
    <%= _.camelCase(className) %>Methods,
  ];

  <% } %>
}
