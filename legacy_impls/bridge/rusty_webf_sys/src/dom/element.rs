// Generated by WebF TSDL, don't edit this file directly.
// Generate command: node scripts/generate_binding_code.js
/*
* Copyright (C) 2022-present The WebF authors. All rights reserved.
*/
use std::ffi::*;
use crate::*;
#[repr(C)]
pub struct ElementRustMethods {
  pub version: c_double,
  pub node: NodeRustMethods,
  pub id: extern "C" fn(*const OpaquePtr) -> AtomicStringRef,
  pub set_id: extern "C" fn(*const OpaquePtr, value: *const c_char, *const OpaquePtr) -> bool,
  pub class_name: extern "C" fn(*const OpaquePtr) -> AtomicStringRef,
  pub set_class_name: extern "C" fn(*const OpaquePtr, value: *const c_char, *const OpaquePtr) -> bool,
  pub dataset: extern "C" fn(*const OpaquePtr) -> RustValue<DOMStringMapRustMethods>,
  pub name: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub set_name: extern "C" fn(*const OpaquePtr, value: *const c_char, *const OpaquePtr) -> bool,
  pub attributes: extern "C" fn(*const OpaquePtr) -> RustValue<ElementAttributesRustMethods>,
  pub style: extern "C" fn(*const OpaquePtr) -> RustValue<CSSStyleDeclarationRustMethods>,
  pub client_height: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub client_left: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub client_top: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub client_width: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub outer_html: extern "C" fn(*const OpaquePtr) -> AtomicStringRef,
  pub inner_html: extern "C" fn(*const OpaquePtr) -> AtomicStringRef,
  pub set_inner_html: extern "C" fn(*const OpaquePtr, value: *const c_char, *const OpaquePtr) -> bool,
  pub owner_document: extern "C" fn(*const OpaquePtr) -> RustValue<DocumentRustMethods>,
  pub scroll_left: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub set_scroll_left: extern "C" fn(*const OpaquePtr, value: c_double, *const OpaquePtr) -> bool,
  pub scroll_top: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub set_scroll_top: extern "C" fn(*const OpaquePtr, value: c_double, *const OpaquePtr) -> bool,
  pub scroll_width: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub scroll_height: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub local_name: extern "C" fn(*const OpaquePtr) -> AtomicStringRef,
  pub tag_name: extern "C" fn(*const OpaquePtr) -> AtomicStringRef,
  pub dir: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub set_dir: extern "C" fn(*const OpaquePtr, value: *const c_char, *const OpaquePtr) -> bool,
  pub set_attribute: extern "C" fn(*const OpaquePtr, *const c_char, *const c_char, *const OpaquePtr) -> c_void,
  pub remove_attribute: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> c_void,
  pub has_attribute: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> i32,
  pub get_bounding_client_rect: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> RustValue<BoundingClientRectRustMethods>,
  pub get_client_rects: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> VectorValueRef<BoundingClientRectRustMethods>,
  pub get_elements_by_class_name: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> VectorValueRef<ElementRustMethods>,
  pub get_elements_by_tag_name: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> VectorValueRef<ElementRustMethods>,
  pub query_selector: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> RustValue<ElementRustMethods>,
  pub query_selector_all: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> VectorValueRef<ElementRustMethods>,
  pub matches: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> i32,
  pub closest: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> RustValue<ElementRustMethods>,
  pub scroll: extern "C" fn(*const OpaquePtr, c_double, c_double, *const OpaquePtr) -> c_void,
  pub scroll_with_options: extern "C" fn(*const OpaquePtr, *const ScrollToOptions, *const OpaquePtr) -> c_void,
  pub scroll_by: extern "C" fn(*const OpaquePtr, c_double, c_double, *const OpaquePtr) -> c_void,
  pub scroll_by_with_options: extern "C" fn(*const OpaquePtr, *const ScrollToOptions, *const OpaquePtr) -> c_void,
  pub scroll_to: extern "C" fn(*const OpaquePtr, c_double, c_double, *const OpaquePtr) -> c_void,
  pub scroll_to_with_options: extern "C" fn(*const OpaquePtr, *const ScrollToOptions, *const OpaquePtr) -> c_void,
  pub to_blob: extern "C" fn(*const OpaquePtr, *const WebFNativeFunctionContext, *const OpaquePtr) -> c_void,
  pub to_blob_with_device_pixel_ratio: extern "C" fn(*const OpaquePtr, c_double, *const WebFNativeFunctionContext, *const OpaquePtr) -> c_void,
  pub test_global_to_local: extern "C" fn(*const OpaquePtr, c_double, c_double, *const OpaquePtr) -> NativeValue,
}
pub struct Element {
  pub node: Node,
  method_pointer: *const ElementRustMethods,
}
impl Element {
  pub fn initialize(ptr: *const OpaquePtr, context: *const ExecutingContext, method_pointer: *const ElementRustMethods, status: *const RustValueStatus) -> Element {
    unsafe {
      Element {
        node: Node::initialize(
          ptr,
          context,
          &(method_pointer).as_ref().unwrap().node,
          status,
        ),
        method_pointer,
      }
    }
  }
  pub fn ptr(&self) -> *const OpaquePtr {
    self.node.ptr()
  }
  pub fn context<'a>(&self) -> &'a ExecutingContext {
    self.node.context()
  }
  pub fn id(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).id)(self.ptr())
    };
    value.to_string()
  }
  pub fn set_id(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_id)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn class_name(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).class_name)(self.ptr())
    };
    value.to_string()
  }
  pub fn set_class_name(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_class_name)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn dataset(&self) -> DOMStringMap {
    let value = unsafe {
      ((*self.method_pointer).dataset)(self.ptr())
    };
    DOMStringMap::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn name(&self, exception_state: &ExceptionState) -> String {
    let value = unsafe {
      ((*self.method_pointer).name)(self.ptr(), exception_state.ptr)
    };
    value.to_string()
  }
  pub fn set_name(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_name)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn attributes(&self) -> ElementAttributes {
    let value = unsafe {
      ((*self.method_pointer).attributes)(self.ptr())
    };
    ElementAttributes::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn style(&self) -> CSSStyleDeclaration {
    let value = unsafe {
      ((*self.method_pointer).style)(self.ptr())
    };
    CSSStyleDeclaration::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn client_height(&self, exception_state: &ExceptionState) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).client_height)(self.ptr(), exception_state.ptr)
    };
    value.to_float64()
  }
  pub fn client_left(&self, exception_state: &ExceptionState) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).client_left)(self.ptr(), exception_state.ptr)
    };
    value.to_float64()
  }
  pub fn client_top(&self, exception_state: &ExceptionState) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).client_top)(self.ptr(), exception_state.ptr)
    };
    value.to_float64()
  }
  pub fn client_width(&self, exception_state: &ExceptionState) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).client_width)(self.ptr(), exception_state.ptr)
    };
    value.to_float64()
  }
  pub fn outer_html(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).outer_html)(self.ptr())
    };
    value.to_string()
  }
  pub fn inner_html(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).inner_html)(self.ptr())
    };
    value.to_string()
  }
  pub fn set_inner_html(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_inner_html)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn owner_document(&self) -> Document {
    let value = unsafe {
      ((*self.method_pointer).owner_document)(self.ptr())
    };
    Document::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn scroll_left(&self, exception_state: &ExceptionState) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).scroll_left)(self.ptr(), exception_state.ptr)
    };
    value.to_float64()
  }
  pub fn set_scroll_left(&self, value: f64, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_scroll_left)(self.ptr(), value, exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn scroll_top(&self, exception_state: &ExceptionState) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).scroll_top)(self.ptr(), exception_state.ptr)
    };
    value.to_float64()
  }
  pub fn set_scroll_top(&self, value: f64, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_scroll_top)(self.ptr(), value, exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn scroll_width(&self, exception_state: &ExceptionState) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).scroll_width)(self.ptr(), exception_state.ptr)
    };
    value.to_float64()
  }
  pub fn scroll_height(&self, exception_state: &ExceptionState) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).scroll_height)(self.ptr(), exception_state.ptr)
    };
    value.to_float64()
  }
  pub fn local_name(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).local_name)(self.ptr())
    };
    value.to_string()
  }
  pub fn tag_name(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).tag_name)(self.ptr())
    };
    value.to_string()
  }
  pub fn dir(&self, exception_state: &ExceptionState) -> String {
    let value = unsafe {
      ((*self.method_pointer).dir)(self.ptr(), exception_state.ptr)
    };
    value.to_string()
  }
  pub fn set_dir(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_dir)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn set_attribute(&self, qualified_name: &str, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_attribute)(self.ptr(), CString::new(qualified_name).unwrap().as_ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn remove_attribute(&self, qualified_name: &str, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).remove_attribute)(self.ptr(), CString::new(qualified_name).unwrap().as_ptr(), exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn has_attribute(&self, qualified_name: &str, exception_state: &ExceptionState) -> Result<bool, String> {
    let value = unsafe {
      ((*self.method_pointer).has_attribute)(self.ptr(), CString::new(qualified_name).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(value != 0)
  }
  pub fn get_bounding_client_rect(&self, exception_state: &ExceptionState) -> Result<BoundingClientRect, String> {
    let value = unsafe {
      ((*self.method_pointer).get_bounding_client_rect)(self.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(BoundingClientRect::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn get_client_rects(&self, exception_state: &ExceptionState) -> Result<Vec<BoundingClientRect>, String> {
    let value = unsafe {
      ((*self.method_pointer).get_client_rects)(self.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    let size = value.size as usize;
    let mut result = Vec::with_capacity(size);
    for i in 0..size {
      let value = unsafe { &*value.data.add(i) };
      let value = BoundingClientRect::initialize(value.value, self.context(), value.method_pointer, value.status);
      result.push(value);
    }
    Ok(result)
  }
  pub fn get_elements_by_class_name(&self, class_name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    let value = unsafe {
      ((*self.method_pointer).get_elements_by_class_name)(self.ptr(), CString::new(class_name).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    let size = value.size as usize;
    let mut result = Vec::with_capacity(size);
    for i in 0..size {
      let value = unsafe { &*value.data.add(i) };
      let value = Element::initialize(value.value, self.context(), value.method_pointer, value.status);
      result.push(value);
    }
    Ok(result)
  }
  pub fn get_elements_by_tag_name(&self, tag_name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    let value = unsafe {
      ((*self.method_pointer).get_elements_by_tag_name)(self.ptr(), CString::new(tag_name).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    let size = value.size as usize;
    let mut result = Vec::with_capacity(size);
    for i in 0..size {
      let value = unsafe { &*value.data.add(i) };
      let value = Element::initialize(value.value, self.context(), value.method_pointer, value.status);
      result.push(value);
    }
    Ok(result)
  }
  pub fn query_selector(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Element, String> {
    let value = unsafe {
      ((*self.method_pointer).query_selector)(self.ptr(), CString::new(selectors).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Element::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn query_selector_all(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    let value = unsafe {
      ((*self.method_pointer).query_selector_all)(self.ptr(), CString::new(selectors).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    let size = value.size as usize;
    let mut result = Vec::with_capacity(size);
    for i in 0..size {
      let value = unsafe { &*value.data.add(i) };
      let value = Element::initialize(value.value, self.context(), value.method_pointer, value.status);
      result.push(value);
    }
    Ok(result)
  }
  pub fn matches(&self, selectors: &str, exception_state: &ExceptionState) -> Result<bool, String> {
    let value = unsafe {
      ((*self.method_pointer).matches)(self.ptr(), CString::new(selectors).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(value != 0)
  }
  pub fn closest(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Element, String> {
    let value = unsafe {
      ((*self.method_pointer).closest)(self.ptr(), CString::new(selectors).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Element::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn scroll(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).scroll)(self.ptr(), x, y, exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn scroll_with_options(&self, options: &ScrollToOptions, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).scroll_with_options)(self.ptr(), options, exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn scroll_by(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).scroll_by)(self.ptr(), x, y, exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn scroll_by_with_options(&self, options: &ScrollToOptions, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).scroll_by_with_options)(self.ptr(), options, exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn scroll_to(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).scroll_to)(self.ptr(), x, y, exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn scroll_to_with_options(&self, options: &ScrollToOptions, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).scroll_to_with_options)(self.ptr(), options, exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn to_blob(&self, exception_state: &ExceptionState) -> WebFNativeFuture<Vec<u8>> {
    let event_target: &EventTarget = &self.node.event_target;
    let future_for_return = WebFNativeFuture::<Vec<u8>>::new();
    let future_in_callback = future_for_return.clone();
    let general_callback: WebFNativeFunction = Box::new(move |argc, argv| {
      if argc == 1 {
        let error_string = unsafe { (*argv).clone() };
        let error_string = error_string.to_string();
        future_in_callback.set_result(Err(error_string));
        return NativeValue::new_null();
      }
      if argc == 2 {
        let result = unsafe { (*argv.wrapping_add(1)).clone() };
        let value = result.to_u8_bytes();
        future_in_callback.set_result(Ok(Some(value)));
        return NativeValue::new_null();
      }
      println!("Invalid argument count for async storage callback");
      NativeValue::new_null()
    });
    let callback_data = Box::new(WebFNativeFunctionContextData {
      func: general_callback,
    });
    let callback_context_data_ptr = Box::into_raw(callback_data);
    let callback_context = Box::new(WebFNativeFunctionContext {
      callback: invoke_webf_native_function,
      free_ptr: release_webf_native_function,
      ptr: callback_context_data_ptr,
    });
    let callback_context_ptr = Box::into_raw(callback_context);
    unsafe {
      (((*self.method_pointer).to_blob))(event_target.ptr, callback_context_ptr, exception_state.ptr);
    }
    future_for_return
  }
  pub fn to_blob_with_device_pixel_ratio(&self, device_pixel_ratio: f64, exception_state: &ExceptionState) -> WebFNativeFuture<Vec<u8>> {
    let event_target: &EventTarget = &self.node.event_target;
    let future_for_return = WebFNativeFuture::<Vec<u8>>::new();
    let future_in_callback = future_for_return.clone();
    let general_callback: WebFNativeFunction = Box::new(move |argc, argv| {
      if argc == 1 {
        let error_string = unsafe { (*argv).clone() };
        let error_string = error_string.to_string();
        future_in_callback.set_result(Err(error_string));
        return NativeValue::new_null();
      }
      if argc == 2 {
        let result = unsafe { (*argv.wrapping_add(1)).clone() };
        let value = result.to_u8_bytes();
        future_in_callback.set_result(Ok(Some(value)));
        return NativeValue::new_null();
      }
      println!("Invalid argument count for async storage callback");
      NativeValue::new_null()
    });
    let callback_data = Box::new(WebFNativeFunctionContextData {
      func: general_callback,
    });
    let callback_context_data_ptr = Box::into_raw(callback_data);
    let callback_context = Box::new(WebFNativeFunctionContext {
      callback: invoke_webf_native_function,
      free_ptr: release_webf_native_function,
      ptr: callback_context_data_ptr,
    });
    let callback_context_ptr = Box::into_raw(callback_context);
    unsafe {
      (((*self.method_pointer).to_blob_with_device_pixel_ratio))(event_target.ptr, device_pixel_ratio, callback_context_ptr, exception_state.ptr);
    }
    future_for_return
  }
  pub fn test_global_to_local(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<NativeValue, String> {
    let value = unsafe {
      ((*self.method_pointer).test_global_to_local)(self.ptr(), x, y, exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(value)
  }
}
pub trait ElementMethods: NodeMethods {
  fn id(&self) -> String;
  fn set_id(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String>;
  fn class_name(&self) -> String;
  fn set_class_name(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String>;
  fn dataset(&self) -> DOMStringMap;
  fn name(&self, exception_state: &ExceptionState) -> String;
  fn set_name(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String>;
  fn attributes(&self) -> ElementAttributes;
  fn style(&self) -> CSSStyleDeclaration;
  fn client_height(&self, exception_state: &ExceptionState) -> f64;
  fn client_left(&self, exception_state: &ExceptionState) -> f64;
  fn client_top(&self, exception_state: &ExceptionState) -> f64;
  fn client_width(&self, exception_state: &ExceptionState) -> f64;
  fn outer_html(&self) -> String;
  fn inner_html(&self) -> String;
  fn set_inner_html(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String>;
  fn owner_document(&self) -> Document;
  fn scroll_left(&self, exception_state: &ExceptionState) -> f64;
  fn set_scroll_left(&self, value: f64, exception_state: &ExceptionState) -> Result<(), String>;
  fn scroll_top(&self, exception_state: &ExceptionState) -> f64;
  fn set_scroll_top(&self, value: f64, exception_state: &ExceptionState) -> Result<(), String>;
  fn scroll_width(&self, exception_state: &ExceptionState) -> f64;
  fn scroll_height(&self, exception_state: &ExceptionState) -> f64;
  fn local_name(&self) -> String;
  fn tag_name(&self) -> String;
  fn dir(&self, exception_state: &ExceptionState) -> String;
  fn set_dir(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String>;
  fn set_attribute(&self, qualified_name: &str, value: &str, exception_state: &ExceptionState) -> Result<(), String>;
  fn remove_attribute(&self, qualified_name: &str, exception_state: &ExceptionState) -> Result<(), String>;
  fn has_attribute(&self, qualified_name: &str, exception_state: &ExceptionState) -> Result<bool, String>;
  fn get_bounding_client_rect(&self, exception_state: &ExceptionState) -> Result<BoundingClientRect, String>;
  fn get_client_rects(&self, exception_state: &ExceptionState) -> Result<Vec<BoundingClientRect>, String>;
  fn get_elements_by_class_name(&self, class_name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String>;
  fn get_elements_by_tag_name(&self, tag_name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String>;
  fn query_selector(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Element, String>;
  fn query_selector_all(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String>;
  fn matches(&self, selectors: &str, exception_state: &ExceptionState) -> Result<bool, String>;
  fn closest(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Element, String>;
  fn scroll(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<(), String>;
  fn scroll_with_options(&self, options: &ScrollToOptions, exception_state: &ExceptionState) -> Result<(), String>;
  fn scroll_by(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<(), String>;
  fn scroll_by_with_options(&self, options: &ScrollToOptions, exception_state: &ExceptionState) -> Result<(), String>;
  fn scroll_to(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<(), String>;
  fn scroll_to_with_options(&self, options: &ScrollToOptions, exception_state: &ExceptionState) -> Result<(), String>;
  fn to_blob(&self, exception_state: &ExceptionState) -> WebFNativeFuture<Vec<u8>>;
  fn to_blob_with_device_pixel_ratio(&self, device_pixel_ratio: f64, exception_state: &ExceptionState) -> WebFNativeFuture<Vec<u8>>;
  fn test_global_to_local(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<NativeValue, String>;
  fn as_element(&self) -> &Element;
}
impl ElementMethods for Element {
  fn id(&self) -> String {
    self.id()
  }
  fn set_id(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_id(value, exception_state)
  }
  fn class_name(&self) -> String {
    self.class_name()
  }
  fn set_class_name(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_class_name(value, exception_state)
  }
  fn dataset(&self) -> DOMStringMap {
    self.dataset()
  }
  fn name(&self, exception_state: &ExceptionState) -> String {
    self.name(exception_state)
  }
  fn set_name(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_name(value, exception_state)
  }
  fn attributes(&self) -> ElementAttributes {
    self.attributes()
  }
  fn style(&self) -> CSSStyleDeclaration {
    self.style()
  }
  fn client_height(&self, exception_state: &ExceptionState) -> f64 {
    self.client_height(exception_state)
  }
  fn client_left(&self, exception_state: &ExceptionState) -> f64 {
    self.client_left(exception_state)
  }
  fn client_top(&self, exception_state: &ExceptionState) -> f64 {
    self.client_top(exception_state)
  }
  fn client_width(&self, exception_state: &ExceptionState) -> f64 {
    self.client_width(exception_state)
  }
  fn outer_html(&self) -> String {
    self.outer_html()
  }
  fn inner_html(&self) -> String {
    self.inner_html()
  }
  fn set_inner_html(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_inner_html(value, exception_state)
  }
  fn owner_document(&self) -> Document {
    self.owner_document()
  }
  fn scroll_left(&self, exception_state: &ExceptionState) -> f64 {
    self.scroll_left(exception_state)
  }
  fn set_scroll_left(&self, value: f64, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_scroll_left(value, exception_state)
  }
  fn scroll_top(&self, exception_state: &ExceptionState) -> f64 {
    self.scroll_top(exception_state)
  }
  fn set_scroll_top(&self, value: f64, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_scroll_top(value, exception_state)
  }
  fn scroll_width(&self, exception_state: &ExceptionState) -> f64 {
    self.scroll_width(exception_state)
  }
  fn scroll_height(&self, exception_state: &ExceptionState) -> f64 {
    self.scroll_height(exception_state)
  }
  fn local_name(&self) -> String {
    self.local_name()
  }
  fn tag_name(&self) -> String {
    self.tag_name()
  }
  fn dir(&self, exception_state: &ExceptionState) -> String {
    self.dir(exception_state)
  }
  fn set_dir(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_dir(value, exception_state)
  }
  fn set_attribute(&self, qualified_name: &str, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_attribute(qualified_name, value, exception_state)
  }
  fn remove_attribute(&self, qualified_name: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.remove_attribute(qualified_name, exception_state)
  }
  fn has_attribute(&self, qualified_name: &str, exception_state: &ExceptionState) -> Result<bool, String> {
    self.has_attribute(qualified_name, exception_state)
  }
  fn get_bounding_client_rect(&self, exception_state: &ExceptionState) -> Result<BoundingClientRect, String> {
    self.get_bounding_client_rect(exception_state)
  }
  fn get_client_rects(&self, exception_state: &ExceptionState) -> Result<Vec<BoundingClientRect>, String> {
    self.get_client_rects(exception_state)
  }
  fn get_elements_by_class_name(&self, class_name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    self.get_elements_by_class_name(class_name, exception_state)
  }
  fn get_elements_by_tag_name(&self, tag_name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    self.get_elements_by_tag_name(tag_name, exception_state)
  }
  fn query_selector(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Element, String> {
    self.query_selector(selectors, exception_state)
  }
  fn query_selector_all(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    self.query_selector_all(selectors, exception_state)
  }
  fn matches(&self, selectors: &str, exception_state: &ExceptionState) -> Result<bool, String> {
    self.matches(selectors, exception_state)
  }
  fn closest(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Element, String> {
    self.closest(selectors, exception_state)
  }
  fn scroll(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<(), String> {
    self.scroll(x, y, exception_state)
  }
  fn scroll_with_options(&self, options: &ScrollToOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.scroll_with_options(options, exception_state)
  }
  fn scroll_by(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<(), String> {
    self.scroll_by(x, y, exception_state)
  }
  fn scroll_by_with_options(&self, options: &ScrollToOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.scroll_by_with_options(options, exception_state)
  }
  fn scroll_to(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<(), String> {
    self.scroll_to(x, y, exception_state)
  }
  fn scroll_to_with_options(&self, options: &ScrollToOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.scroll_to_with_options(options, exception_state)
  }
  fn to_blob(&self, exception_state: &ExceptionState) -> WebFNativeFuture<Vec<u8>> {
    self.to_blob(exception_state)
  }
  fn to_blob_with_device_pixel_ratio(&self, device_pixel_ratio: f64, exception_state: &ExceptionState) -> WebFNativeFuture<Vec<u8>> {
    self.to_blob_with_device_pixel_ratio(device_pixel_ratio, exception_state)
  }
  fn test_global_to_local(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<NativeValue, String> {
    self.test_global_to_local(x, y, exception_state)
  }
  fn as_element(&self) -> &Element {
    self
  }
}
impl NodeMethods for Element {
  fn element_node(&self) -> f64 {
    self.node.element_node()
  }
  fn attribute_node(&self) -> f64 {
    self.node.attribute_node()
  }
  fn text_node(&self) -> f64 {
    self.node.text_node()
  }
  fn comment_node(&self) -> f64 {
    self.node.comment_node()
  }
  fn document_node(&self) -> f64 {
    self.node.document_node()
  }
  fn document_type_node(&self) -> f64 {
    self.node.document_type_node()
  }
  fn document_fragment_node(&self) -> f64 {
    self.node.document_fragment_node()
  }
  fn node_type(&self) -> f64 {
    self.node.node_type()
  }
  fn node_name(&self) -> String {
    self.node.node_name()
  }
  fn child_nodes(&self) -> NodeList {
    self.node.child_nodes()
  }
  fn first_child(&self) -> Node {
    self.node.first_child()
  }
  fn is_connected(&self) -> bool {
    self.node.is_connected()
  }
  fn last_child(&self) -> Node {
    self.node.last_child()
  }
  fn next_sibling(&self) -> Node {
    self.node.next_sibling()
  }
  fn owner_document(&self) -> Document {
    self.node.owner_document()
  }
  fn parent_element(&self) -> Element {
    self.node.parent_element()
  }
  fn parent_node(&self) -> Node {
    self.node.parent_node()
  }
  fn previous_sibling(&self) -> Node {
    self.node.previous_sibling()
  }
  fn has_child_nodes(&self, exception_state: &ExceptionState) -> Result<bool, String> {
    self.node.has_child_nodes(exception_state)
  }
  fn append_child(&self, new_node: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.node.append_child(new_node, exception_state)
  }
  fn clone_node(&self, deep: bool, exception_state: &ExceptionState) -> Result<Node, String> {
    self.node.clone_node(deep, exception_state)
  }
  fn contains(&self, other: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.node.contains(other, exception_state)
  }
  fn insert_before(&self, new_child: &Node, ref_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.node.insert_before(new_child, ref_child, exception_state)
  }
  fn is_equal_node(&self, other_node: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.node.is_equal_node(other_node, exception_state)
  }
  fn is_same_node(&self, other_node: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.node.is_same_node(other_node, exception_state)
  }
  fn remove_child(&self, old_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.node.remove_child(old_child, exception_state)
  }
  fn remove(&self, exception_state: &ExceptionState) -> Result<(), String> {
    self.node.remove(exception_state)
  }
  fn replace_child(&self, new_child: &Node, old_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.node.replace_child(new_child, old_child, exception_state)
  }
  fn as_node(&self) -> &Node {
    &self.node
  }
}
impl EventTargetMethods for Element {
  fn add_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &AddEventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.node.event_target.add_event_listener(type_, callback, options, exception_state)
  }
  fn remove_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &EventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.node.event_target.remove_event_listener(type_, callback, options, exception_state)
  }
  fn dispatch_event(&self, event: &Event, exception_state: &ExceptionState) -> Result<bool, String> {
    self.node.event_target.dispatch_event(event, exception_state)
  }
  fn as_event_target(&self) -> &EventTarget {
    &self.node.event_target
  }
}
