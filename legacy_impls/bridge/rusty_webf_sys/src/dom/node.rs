// Generated by WebF TSDL, don't edit this file directly.
// Generate command: node scripts/generate_binding_code.js
/*
* Copyright (C) 2022-present The WebF authors. All rights reserved.
*/
use std::ffi::*;
use crate::*;
#[repr(C)]
pub struct NodeRustMethods {
  pub version: c_double,
  pub event_target: EventTargetRustMethods,
  pub element_node: extern "C" fn(*const OpaquePtr) -> c_double,
  pub attribute_node: extern "C" fn(*const OpaquePtr) -> c_double,
  pub text_node: extern "C" fn(*const OpaquePtr) -> c_double,
  pub comment_node: extern "C" fn(*const OpaquePtr) -> c_double,
  pub document_node: extern "C" fn(*const OpaquePtr) -> c_double,
  pub document_type_node: extern "C" fn(*const OpaquePtr) -> c_double,
  pub document_fragment_node: extern "C" fn(*const OpaquePtr) -> c_double,
  pub node_type: extern "C" fn(*const OpaquePtr) -> c_double,
  pub node_name: extern "C" fn(*const OpaquePtr) -> AtomicStringRef,
  pub child_nodes: extern "C" fn(*const OpaquePtr) -> RustValue<NodeListRustMethods>,
  pub first_child: extern "C" fn(*const OpaquePtr) -> RustValue<NodeRustMethods>,
  pub is_connected: extern "C" fn(*const OpaquePtr) -> i32,
  pub last_child: extern "C" fn(*const OpaquePtr) -> RustValue<NodeRustMethods>,
  pub next_sibling: extern "C" fn(*const OpaquePtr) -> RustValue<NodeRustMethods>,
  pub owner_document: extern "C" fn(*const OpaquePtr) -> RustValue<DocumentRustMethods>,
  pub parent_element: extern "C" fn(*const OpaquePtr) -> RustValue<ElementRustMethods>,
  pub parent_node: extern "C" fn(*const OpaquePtr) -> RustValue<NodeRustMethods>,
  pub previous_sibling: extern "C" fn(*const OpaquePtr) -> RustValue<NodeRustMethods>,
  pub has_child_nodes: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> i32,
  pub append_child: extern "C" fn(*const OpaquePtr, *const OpaquePtr, *const OpaquePtr) -> RustValue<NodeRustMethods>,
  pub clone_node: extern "C" fn(*const OpaquePtr, i32, *const OpaquePtr) -> RustValue<NodeRustMethods>,
  pub contains: extern "C" fn(*const OpaquePtr, *const OpaquePtr, *const OpaquePtr) -> i32,
  pub insert_before: extern "C" fn(*const OpaquePtr, *const OpaquePtr, *const OpaquePtr, *const OpaquePtr) -> RustValue<NodeRustMethods>,
  pub is_equal_node: extern "C" fn(*const OpaquePtr, *const OpaquePtr, *const OpaquePtr) -> i32,
  pub is_same_node: extern "C" fn(*const OpaquePtr, *const OpaquePtr, *const OpaquePtr) -> i32,
  pub remove_child: extern "C" fn(*const OpaquePtr, *const OpaquePtr, *const OpaquePtr) -> RustValue<NodeRustMethods>,
  pub remove: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> c_void,
  pub replace_child: extern "C" fn(*const OpaquePtr, *const OpaquePtr, *const OpaquePtr, *const OpaquePtr) -> RustValue<NodeRustMethods>,
}
pub struct Node {
  pub event_target: EventTarget,
  method_pointer: *const NodeRustMethods,
}
impl Node {
  pub fn initialize(ptr: *const OpaquePtr, context: *const ExecutingContext, method_pointer: *const NodeRustMethods, status: *const RustValueStatus) -> Node {
    unsafe {
      Node {
        event_target: EventTarget::initialize(
          ptr,
          context,
          &(method_pointer).as_ref().unwrap().event_target,
          status,
        ),
        method_pointer,
      }
    }
  }
  pub fn ptr(&self) -> *const OpaquePtr {
    self.event_target.ptr()
  }
  pub fn context<'a>(&self) -> &'a ExecutingContext {
    self.event_target.context()
  }
  pub fn element_node(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).element_node)(self.ptr())
    };
    value
  }
  pub fn attribute_node(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).attribute_node)(self.ptr())
    };
    value
  }
  pub fn text_node(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).text_node)(self.ptr())
    };
    value
  }
  pub fn comment_node(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).comment_node)(self.ptr())
    };
    value
  }
  pub fn document_node(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).document_node)(self.ptr())
    };
    value
  }
  pub fn document_type_node(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).document_type_node)(self.ptr())
    };
    value
  }
  pub fn document_fragment_node(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).document_fragment_node)(self.ptr())
    };
    value
  }
  pub fn node_type(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).node_type)(self.ptr())
    };
    value
  }
  pub fn node_name(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).node_name)(self.ptr())
    };
    value.to_string()
  }
  pub fn child_nodes(&self) -> NodeList {
    let value = unsafe {
      ((*self.method_pointer).child_nodes)(self.ptr())
    };
    NodeList::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn first_child(&self) -> Node {
    let value = unsafe {
      ((*self.method_pointer).first_child)(self.ptr())
    };
    Node::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn is_connected(&self) -> bool {
    let value = unsafe {
      ((*self.method_pointer).is_connected)(self.ptr())
    };
    value != 0
  }
  pub fn last_child(&self) -> Node {
    let value = unsafe {
      ((*self.method_pointer).last_child)(self.ptr())
    };
    Node::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn next_sibling(&self) -> Node {
    let value = unsafe {
      ((*self.method_pointer).next_sibling)(self.ptr())
    };
    Node::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn owner_document(&self) -> Document {
    let value = unsafe {
      ((*self.method_pointer).owner_document)(self.ptr())
    };
    Document::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn parent_element(&self) -> Element {
    let value = unsafe {
      ((*self.method_pointer).parent_element)(self.ptr())
    };
    Element::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn parent_node(&self) -> Node {
    let value = unsafe {
      ((*self.method_pointer).parent_node)(self.ptr())
    };
    Node::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn previous_sibling(&self) -> Node {
    let value = unsafe {
      ((*self.method_pointer).previous_sibling)(self.ptr())
    };
    Node::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn has_child_nodes(&self, exception_state: &ExceptionState) -> Result<bool, String> {
    let value = unsafe {
      ((*self.method_pointer).has_child_nodes)(self.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(value != 0)
  }
  pub fn append_child(&self, new_node: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    let value = unsafe {
      ((*self.method_pointer).append_child)(self.ptr(), new_node.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Node::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn clone_node(&self, deep: bool, exception_state: &ExceptionState) -> Result<Node, String> {
    let value = unsafe {
      ((*self.method_pointer).clone_node)(self.ptr(), i32::from(deep), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Node::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn contains(&self, other: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    let value = unsafe {
      ((*self.method_pointer).contains)(self.ptr(), other.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(value != 0)
  }
  pub fn insert_before(&self, new_child: &Node, ref_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    let value = unsafe {
      ((*self.method_pointer).insert_before)(self.ptr(), new_child.ptr(), ref_child.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Node::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn is_equal_node(&self, other_node: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    let value = unsafe {
      ((*self.method_pointer).is_equal_node)(self.ptr(), other_node.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(value != 0)
  }
  pub fn is_same_node(&self, other_node: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    let value = unsafe {
      ((*self.method_pointer).is_same_node)(self.ptr(), other_node.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(value != 0)
  }
  pub fn remove_child(&self, old_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    let value = unsafe {
      ((*self.method_pointer).remove_child)(self.ptr(), old_child.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Node::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn remove(&self, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).remove)(self.ptr(), exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn replace_child(&self, new_child: &Node, old_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    let value = unsafe {
      ((*self.method_pointer).replace_child)(self.ptr(), new_child.ptr(), old_child.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Node::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
}
pub trait NodeMethods: EventTargetMethods {
  fn element_node(&self) -> f64;
  fn attribute_node(&self) -> f64;
  fn text_node(&self) -> f64;
  fn comment_node(&self) -> f64;
  fn document_node(&self) -> f64;
  fn document_type_node(&self) -> f64;
  fn document_fragment_node(&self) -> f64;
  fn node_type(&self) -> f64;
  fn node_name(&self) -> String;
  fn child_nodes(&self) -> NodeList;
  fn first_child(&self) -> Node;
  fn is_connected(&self) -> bool;
  fn last_child(&self) -> Node;
  fn next_sibling(&self) -> Node;
  fn owner_document(&self) -> Document;
  fn parent_element(&self) -> Element;
  fn parent_node(&self) -> Node;
  fn previous_sibling(&self) -> Node;
  fn has_child_nodes(&self, exception_state: &ExceptionState) -> Result<bool, String>;
  fn append_child(&self, new_node: &Node, exception_state: &ExceptionState) -> Result<Node, String>;
  fn clone_node(&self, deep: bool, exception_state: &ExceptionState) -> Result<Node, String>;
  fn contains(&self, other: &Node, exception_state: &ExceptionState) -> Result<bool, String>;
  fn insert_before(&self, new_child: &Node, ref_child: &Node, exception_state: &ExceptionState) -> Result<Node, String>;
  fn is_equal_node(&self, other_node: &Node, exception_state: &ExceptionState) -> Result<bool, String>;
  fn is_same_node(&self, other_node: &Node, exception_state: &ExceptionState) -> Result<bool, String>;
  fn remove_child(&self, old_child: &Node, exception_state: &ExceptionState) -> Result<Node, String>;
  fn remove(&self, exception_state: &ExceptionState) -> Result<(), String>;
  fn replace_child(&self, new_child: &Node, old_child: &Node, exception_state: &ExceptionState) -> Result<Node, String>;
  fn as_node(&self) -> &Node;
}
impl NodeMethods for Node {
  fn element_node(&self) -> f64 {
    self.element_node()
  }
  fn attribute_node(&self) -> f64 {
    self.attribute_node()
  }
  fn text_node(&self) -> f64 {
    self.text_node()
  }
  fn comment_node(&self) -> f64 {
    self.comment_node()
  }
  fn document_node(&self) -> f64 {
    self.document_node()
  }
  fn document_type_node(&self) -> f64 {
    self.document_type_node()
  }
  fn document_fragment_node(&self) -> f64 {
    self.document_fragment_node()
  }
  fn node_type(&self) -> f64 {
    self.node_type()
  }
  fn node_name(&self) -> String {
    self.node_name()
  }
  fn child_nodes(&self) -> NodeList {
    self.child_nodes()
  }
  fn first_child(&self) -> Node {
    self.first_child()
  }
  fn is_connected(&self) -> bool {
    self.is_connected()
  }
  fn last_child(&self) -> Node {
    self.last_child()
  }
  fn next_sibling(&self) -> Node {
    self.next_sibling()
  }
  fn owner_document(&self) -> Document {
    self.owner_document()
  }
  fn parent_element(&self) -> Element {
    self.parent_element()
  }
  fn parent_node(&self) -> Node {
    self.parent_node()
  }
  fn previous_sibling(&self) -> Node {
    self.previous_sibling()
  }
  fn has_child_nodes(&self, exception_state: &ExceptionState) -> Result<bool, String> {
    self.has_child_nodes(exception_state)
  }
  fn append_child(&self, new_node: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.append_child(new_node, exception_state)
  }
  fn clone_node(&self, deep: bool, exception_state: &ExceptionState) -> Result<Node, String> {
    self.clone_node(deep, exception_state)
  }
  fn contains(&self, other: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.contains(other, exception_state)
  }
  fn insert_before(&self, new_child: &Node, ref_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.insert_before(new_child, ref_child, exception_state)
  }
  fn is_equal_node(&self, other_node: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.is_equal_node(other_node, exception_state)
  }
  fn is_same_node(&self, other_node: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.is_same_node(other_node, exception_state)
  }
  fn remove_child(&self, old_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.remove_child(old_child, exception_state)
  }
  fn remove(&self, exception_state: &ExceptionState) -> Result<(), String> {
    self.remove(exception_state)
  }
  fn replace_child(&self, new_child: &Node, old_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.replace_child(new_child, old_child, exception_state)
  }
  fn as_node(&self) -> &Node {
    self
  }
}
impl EventTargetMethods for Node {
  fn add_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &AddEventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.event_target.add_event_listener(type_, callback, options, exception_state)
  }
  fn remove_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &EventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.event_target.remove_event_listener(type_, callback, options, exception_state)
  }
  fn dispatch_event(&self, event: &Event, exception_state: &ExceptionState) -> Result<bool, String> {
    self.event_target.dispatch_event(event, exception_state)
  }
  fn as_event_target(&self) -> &EventTarget {
    &self.event_target
  }
}
