// Generated by WebF TSDL, don't edit this file directly.
// Generate command: node scripts/generate_binding_code.js
/*
* Copyright (C) 2022-present The WebF authors. All rights reserved.
*/
use std::ffi::*;
use crate::*;
#[repr(C)]
pub struct DocumentRustMethods {
  pub version: c_double,
  pub node: NodeRustMethods,
  pub title: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub set_title: extern "C" fn(*const OpaquePtr, value: *const c_char, *const OpaquePtr) -> bool,
  pub body: extern "C" fn(*const OpaquePtr) -> RustValue<HTMLBodyElementRustMethods>,
  pub set_body: extern "C" fn(*const OpaquePtr, value: *const OpaquePtr, *const OpaquePtr) -> bool,
  pub cookie: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub set_cookie: extern "C" fn(*const OpaquePtr, value: *const c_char, *const OpaquePtr) -> bool,
  pub domain: extern "C" fn(*const OpaquePtr) -> AtomicStringRef,
  pub set_domain: extern "C" fn(*const OpaquePtr, value: *const c_char, *const OpaquePtr) -> bool,
  pub head: extern "C" fn(*const OpaquePtr) -> RustValue<HTMLHeadElementRustMethods>,
  pub document_element: extern "C" fn(*const OpaquePtr) -> RustValue<HTMLHtmlElementRustMethods>,
  pub location: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub compat_mode: extern "C" fn(*const OpaquePtr) -> AtomicStringRef,
  pub ready_state: extern "C" fn(*const OpaquePtr) -> AtomicStringRef,
  pub visibility_state: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub hidden: extern "C" fn(*const OpaquePtr) -> i32,
  pub default_view: extern "C" fn(*const OpaquePtr) -> RustValue<WindowRustMethods>,
  pub clear_cookies: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> c_void,
  pub create_element: extern "C" fn(*const OpaquePtr, *const c_char, NativeValue, *const OpaquePtr) -> RustValue<ElementRustMethods>,
  pub create_text_node: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> RustValue<TextRustMethods>,
  pub create_document_fragment: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> RustValue<DocumentFragmentRustMethods>,
  pub create_comment: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> RustValue<CommentRustMethods>,
  pub create_event: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> RustValue<EventRustMethods>,
  pub get_element_by_id: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> RustValue<ElementRustMethods>,
  pub get_elements_by_class_name: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> VectorValueRef<ElementRustMethods>,
  pub get_elements_by_tag_name: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> VectorValueRef<ElementRustMethods>,
  pub get_elements_by_name: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> VectorValueRef<ElementRustMethods>,
  pub query_selector: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> RustValue<ElementRustMethods>,
  pub query_selector_all: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> VectorValueRef<ElementRustMethods>,
  pub element_from_point: extern "C" fn(*const OpaquePtr, c_double, c_double, *const OpaquePtr) -> RustValue<ElementRustMethods>,
}
pub struct Document {
  pub node: Node,
  method_pointer: *const DocumentRustMethods,
}
impl Document {
  pub fn initialize(ptr: *const OpaquePtr, context: *const ExecutingContext, method_pointer: *const DocumentRustMethods, status: *const RustValueStatus) -> Document {
    unsafe {
      Document {
        node: Node::initialize(
          ptr,
          context,
          &(method_pointer).as_ref().unwrap().node,
          status,
        ),
        method_pointer,
      }
    }
  }
  pub fn ptr(&self) -> *const OpaquePtr {
    self.node.ptr()
  }
  pub fn context<'a>(&self) -> &'a ExecutingContext {
    self.node.context()
  }
  pub fn title(&self, exception_state: &ExceptionState) -> String {
    let value = unsafe {
      ((*self.method_pointer).title)(self.ptr(), exception_state.ptr)
    };
    value.to_string()
  }
  pub fn set_title(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_title)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn body(&self) -> HTMLBodyElement {
    let value = unsafe {
      ((*self.method_pointer).body)(self.ptr())
    };
    HTMLBodyElement::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn set_body(&self, value: &HTMLBodyElement, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_body)(self.ptr(), value.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn cookie(&self, exception_state: &ExceptionState) -> String {
    let value = unsafe {
      ((*self.method_pointer).cookie)(self.ptr(), exception_state.ptr)
    };
    value.to_string()
  }
  pub fn set_cookie(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_cookie)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn domain(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).domain)(self.ptr())
    };
    value.to_string()
  }
  pub fn set_domain(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_domain)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn head(&self) -> HTMLHeadElement {
    let value = unsafe {
      ((*self.method_pointer).head)(self.ptr())
    };
    HTMLHeadElement::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn document_element(&self) -> HTMLHtmlElement {
    let value = unsafe {
      ((*self.method_pointer).document_element)(self.ptr())
    };
    HTMLHtmlElement::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn location(&self, exception_state: &ExceptionState) -> NativeValue {
    let value = unsafe {
      ((*self.method_pointer).location)(self.ptr(), exception_state.ptr)
    };
    value
  }
  pub fn compat_mode(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).compat_mode)(self.ptr())
    };
    value.to_string()
  }
  pub fn ready_state(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).ready_state)(self.ptr())
    };
    value.to_string()
  }
  pub fn visibility_state(&self, exception_state: &ExceptionState) -> String {
    let value = unsafe {
      ((*self.method_pointer).visibility_state)(self.ptr(), exception_state.ptr)
    };
    value.to_string()
  }
  pub fn hidden(&self) -> bool {
    let value = unsafe {
      ((*self.method_pointer).hidden)(self.ptr())
    };
    value != 0
  }
  pub fn default_view(&self) -> Window {
    let value = unsafe {
      ((*self.method_pointer).default_view)(self.ptr())
    };
    Window::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn clear_cookies(&self, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).clear_cookies)(self.ptr(), exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn create_element(&self, tag_name: &str, options: NativeValue, exception_state: &ExceptionState) -> Result<Element, String> {
    let value = unsafe {
      ((*self.method_pointer).create_element)(self.ptr(), CString::new(tag_name).unwrap().as_ptr(), options, exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Element::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn create_text_node(&self, value: &str, exception_state: &ExceptionState) -> Result<Text, String> {
    let value = unsafe {
      ((*self.method_pointer).create_text_node)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Text::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn create_document_fragment(&self, exception_state: &ExceptionState) -> Result<DocumentFragment, String> {
    let value = unsafe {
      ((*self.method_pointer).create_document_fragment)(self.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(DocumentFragment::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn create_comment(&self, data: &str, exception_state: &ExceptionState) -> Result<Comment, String> {
    let value = unsafe {
      ((*self.method_pointer).create_comment)(self.ptr(), CString::new(data).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Comment::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn create_event(&self, event_type: &str, exception_state: &ExceptionState) -> Result<Event, String> {
    let value = unsafe {
      ((*self.method_pointer).create_event)(self.ptr(), CString::new(event_type).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Event::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn get_element_by_id(&self, id: &str, exception_state: &ExceptionState) -> Result<Element, String> {
    let value = unsafe {
      ((*self.method_pointer).get_element_by_id)(self.ptr(), CString::new(id).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Element::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn get_elements_by_class_name(&self, class_name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    let value = unsafe {
      ((*self.method_pointer).get_elements_by_class_name)(self.ptr(), CString::new(class_name).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    let size = value.size as usize;
    let mut result = Vec::with_capacity(size);
    for i in 0..size {
      let value = unsafe { &*value.data.add(i) };
      let value = Element::initialize(value.value, self.context(), value.method_pointer, value.status);
      result.push(value);
    }
    Ok(result)
  }
  pub fn get_elements_by_tag_name(&self, tag_name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    let value = unsafe {
      ((*self.method_pointer).get_elements_by_tag_name)(self.ptr(), CString::new(tag_name).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    let size = value.size as usize;
    let mut result = Vec::with_capacity(size);
    for i in 0..size {
      let value = unsafe { &*value.data.add(i) };
      let value = Element::initialize(value.value, self.context(), value.method_pointer, value.status);
      result.push(value);
    }
    Ok(result)
  }
  pub fn get_elements_by_name(&self, name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    let value = unsafe {
      ((*self.method_pointer).get_elements_by_name)(self.ptr(), CString::new(name).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    let size = value.size as usize;
    let mut result = Vec::with_capacity(size);
    for i in 0..size {
      let value = unsafe { &*value.data.add(i) };
      let value = Element::initialize(value.value, self.context(), value.method_pointer, value.status);
      result.push(value);
    }
    Ok(result)
  }
  pub fn query_selector(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Element, String> {
    let value = unsafe {
      ((*self.method_pointer).query_selector)(self.ptr(), CString::new(selectors).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Element::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn query_selector_all(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    let value = unsafe {
      ((*self.method_pointer).query_selector_all)(self.ptr(), CString::new(selectors).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    let size = value.size as usize;
    let mut result = Vec::with_capacity(size);
    for i in 0..size {
      let value = unsafe { &*value.data.add(i) };
      let value = Element::initialize(value.value, self.context(), value.method_pointer, value.status);
      result.push(value);
    }
    Ok(result)
  }
  pub fn element_from_point(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<Element, String> {
    let value = unsafe {
      ((*self.method_pointer).element_from_point)(self.ptr(), x, y, exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Element::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
}
pub trait DocumentMethods: NodeMethods {
  fn title(&self, exception_state: &ExceptionState) -> String;
  fn set_title(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String>;
  fn body(&self) -> HTMLBodyElement;
  fn set_body(&self, value: &HTMLBodyElement, exception_state: &ExceptionState) -> Result<(), String>;
  fn cookie(&self, exception_state: &ExceptionState) -> String;
  fn set_cookie(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String>;
  fn domain(&self) -> String;
  fn set_domain(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String>;
  fn head(&self) -> HTMLHeadElement;
  fn document_element(&self) -> HTMLHtmlElement;
  fn location(&self, exception_state: &ExceptionState) -> NativeValue;
  fn compat_mode(&self) -> String;
  fn ready_state(&self) -> String;
  fn visibility_state(&self, exception_state: &ExceptionState) -> String;
  fn hidden(&self) -> bool;
  fn default_view(&self) -> Window;
  fn clear_cookies(&self, exception_state: &ExceptionState) -> Result<(), String>;
  fn create_element(&self, tag_name: &str, options: NativeValue, exception_state: &ExceptionState) -> Result<Element, String>;
  fn create_text_node(&self, value: &str, exception_state: &ExceptionState) -> Result<Text, String>;
  fn create_document_fragment(&self, exception_state: &ExceptionState) -> Result<DocumentFragment, String>;
  fn create_comment(&self, data: &str, exception_state: &ExceptionState) -> Result<Comment, String>;
  fn create_event(&self, event_type: &str, exception_state: &ExceptionState) -> Result<Event, String>;
  fn get_element_by_id(&self, id: &str, exception_state: &ExceptionState) -> Result<Element, String>;
  fn get_elements_by_class_name(&self, class_name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String>;
  fn get_elements_by_tag_name(&self, tag_name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String>;
  fn get_elements_by_name(&self, name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String>;
  fn query_selector(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Element, String>;
  fn query_selector_all(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String>;
  fn element_from_point(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<Element, String>;
  fn as_document(&self) -> &Document;
}
impl DocumentMethods for Document {
  fn title(&self, exception_state: &ExceptionState) -> String {
    self.title(exception_state)
  }
  fn set_title(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_title(value, exception_state)
  }
  fn body(&self) -> HTMLBodyElement {
    self.body()
  }
  fn set_body(&self, value: &HTMLBodyElement, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_body(value, exception_state)
  }
  fn cookie(&self, exception_state: &ExceptionState) -> String {
    self.cookie(exception_state)
  }
  fn set_cookie(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_cookie(value, exception_state)
  }
  fn domain(&self) -> String {
    self.domain()
  }
  fn set_domain(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_domain(value, exception_state)
  }
  fn head(&self) -> HTMLHeadElement {
    self.head()
  }
  fn document_element(&self) -> HTMLHtmlElement {
    self.document_element()
  }
  fn location(&self, exception_state: &ExceptionState) -> NativeValue {
    self.location(exception_state)
  }
  fn compat_mode(&self) -> String {
    self.compat_mode()
  }
  fn ready_state(&self) -> String {
    self.ready_state()
  }
  fn visibility_state(&self, exception_state: &ExceptionState) -> String {
    self.visibility_state(exception_state)
  }
  fn hidden(&self) -> bool {
    self.hidden()
  }
  fn default_view(&self) -> Window {
    self.default_view()
  }
  fn clear_cookies(&self, exception_state: &ExceptionState) -> Result<(), String> {
    self.clear_cookies(exception_state)
  }
  fn create_element(&self, tag_name: &str, options: NativeValue, exception_state: &ExceptionState) -> Result<Element, String> {
    self.create_element(tag_name, options, exception_state)
  }
  fn create_text_node(&self, value: &str, exception_state: &ExceptionState) -> Result<Text, String> {
    self.create_text_node(value, exception_state)
  }
  fn create_document_fragment(&self, exception_state: &ExceptionState) -> Result<DocumentFragment, String> {
    self.create_document_fragment(exception_state)
  }
  fn create_comment(&self, data: &str, exception_state: &ExceptionState) -> Result<Comment, String> {
    self.create_comment(data, exception_state)
  }
  fn create_event(&self, event_type: &str, exception_state: &ExceptionState) -> Result<Event, String> {
    self.create_event(event_type, exception_state)
  }
  fn get_element_by_id(&self, id: &str, exception_state: &ExceptionState) -> Result<Element, String> {
    self.get_element_by_id(id, exception_state)
  }
  fn get_elements_by_class_name(&self, class_name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    self.get_elements_by_class_name(class_name, exception_state)
  }
  fn get_elements_by_tag_name(&self, tag_name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    self.get_elements_by_tag_name(tag_name, exception_state)
  }
  fn get_elements_by_name(&self, name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    self.get_elements_by_name(name, exception_state)
  }
  fn query_selector(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Element, String> {
    self.query_selector(selectors, exception_state)
  }
  fn query_selector_all(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    self.query_selector_all(selectors, exception_state)
  }
  fn element_from_point(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<Element, String> {
    self.element_from_point(x, y, exception_state)
  }
  fn as_document(&self) -> &Document {
    self
  }
}
impl NodeMethods for Document {
  fn element_node(&self) -> f64 {
    self.node.element_node()
  }
  fn attribute_node(&self) -> f64 {
    self.node.attribute_node()
  }
  fn text_node(&self) -> f64 {
    self.node.text_node()
  }
  fn comment_node(&self) -> f64 {
    self.node.comment_node()
  }
  fn document_node(&self) -> f64 {
    self.node.document_node()
  }
  fn document_type_node(&self) -> f64 {
    self.node.document_type_node()
  }
  fn document_fragment_node(&self) -> f64 {
    self.node.document_fragment_node()
  }
  fn node_type(&self) -> f64 {
    self.node.node_type()
  }
  fn node_name(&self) -> String {
    self.node.node_name()
  }
  fn child_nodes(&self) -> NodeList {
    self.node.child_nodes()
  }
  fn first_child(&self) -> Node {
    self.node.first_child()
  }
  fn is_connected(&self) -> bool {
    self.node.is_connected()
  }
  fn last_child(&self) -> Node {
    self.node.last_child()
  }
  fn next_sibling(&self) -> Node {
    self.node.next_sibling()
  }
  fn owner_document(&self) -> Document {
    self.node.owner_document()
  }
  fn parent_element(&self) -> Element {
    self.node.parent_element()
  }
  fn parent_node(&self) -> Node {
    self.node.parent_node()
  }
  fn previous_sibling(&self) -> Node {
    self.node.previous_sibling()
  }
  fn has_child_nodes(&self, exception_state: &ExceptionState) -> Result<bool, String> {
    self.node.has_child_nodes(exception_state)
  }
  fn append_child(&self, new_node: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.node.append_child(new_node, exception_state)
  }
  fn clone_node(&self, deep: bool, exception_state: &ExceptionState) -> Result<Node, String> {
    self.node.clone_node(deep, exception_state)
  }
  fn contains(&self, other: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.node.contains(other, exception_state)
  }
  fn insert_before(&self, new_child: &Node, ref_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.node.insert_before(new_child, ref_child, exception_state)
  }
  fn is_equal_node(&self, other_node: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.node.is_equal_node(other_node, exception_state)
  }
  fn is_same_node(&self, other_node: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.node.is_same_node(other_node, exception_state)
  }
  fn remove_child(&self, old_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.node.remove_child(old_child, exception_state)
  }
  fn remove(&self, exception_state: &ExceptionState) -> Result<(), String> {
    self.node.remove(exception_state)
  }
  fn replace_child(&self, new_child: &Node, old_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.node.replace_child(new_child, old_child, exception_state)
  }
  fn as_node(&self) -> &Node {
    &self.node
  }
}
impl EventTargetMethods for Document {
  fn add_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &AddEventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.node.event_target.add_event_listener(type_, callback, options, exception_state)
  }
  fn remove_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &EventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.node.event_target.remove_event_listener(type_, callback, options, exception_state)
  }
  fn dispatch_event(&self, event: &Event, exception_state: &ExceptionState) -> Result<bool, String> {
    self.node.event_target.dispatch_event(event, exception_state)
  }
  fn as_event_target(&self) -> &EventTarget {
    &self.node.event_target
  }
}
impl ExecutingContext {
  pub fn create_document(&self, exception_state: &ExceptionState) -> Result<Document, String> {
    let new_obj = unsafe {
      ((*self.method_pointer()).create_document)(self.ptr, exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self));
    }
    return Ok(Document::initialize(new_obj.value, self, new_obj.method_pointer, new_obj.status));
  }
}
