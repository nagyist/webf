// Generated by WebF TSDL, don't edit this file directly.
// Generate command: node scripts/generate_binding_code.js
/*
* Copyright (C) 2022-present The WebF authors. All rights reserved.
*/
use std::ffi::*;
use crate::*;
#[repr(C)]
enum EventTargetType {
  EventTarget = 0,
  Screen = 1,
  Window = 2,
  Node = 3,
  CharacterData = 4,
  Comment = 5,
  Text = 6,
  Document = 7,
  DocumentFragment = 8,
  Element = 9,
  HTMLElement = 10,
  HTMLScriptElement = 11,
  HTMLHeadElement = 12,
  HTMLImageElement = 13,
  Image = 14,
  HTMLCanvasElement = 15,
  HTMLHtmlElement = 16,
  HTMLBodyElement = 17,
  HTMLDivElement = 18,
}
#[repr(C)]
pub struct EventTargetRustMethods {
  pub version: c_double,
  pub add_event_listener: extern "C" fn(*const OpaquePtr, *const c_char, *const EventCallbackContext, *const AddEventListenerOptions, *const OpaquePtr) -> c_void,
  pub remove_event_listener: extern "C" fn(*const OpaquePtr, *const c_char, *const EventCallbackContext, *const EventListenerOptions, *const OpaquePtr) -> c_void,
  pub dispatch_event: extern "C" fn(*const OpaquePtr, *const OpaquePtr, *const OpaquePtr) -> i32,
  pub release: extern "C" fn(*const OpaquePtr) -> c_void,
  pub dynamic_to: extern "C" fn(*const OpaquePtr, type_: EventTargetType) -> RustValue<c_void>,
}
pub struct EventTarget {
  pub ptr: *const OpaquePtr,
  context: *const ExecutingContext,
  method_pointer: *const EventTargetRustMethods,
  status: *const RustValueStatus
}
impl EventTarget {
  pub fn initialize(ptr: *const OpaquePtr, context: *const ExecutingContext, method_pointer: *const EventTargetRustMethods, status: *const RustValueStatus) -> EventTarget {
    EventTarget {
      ptr,
      context,
      method_pointer,
      status
    }
  }
  pub fn ptr(&self) -> *const OpaquePtr {
    self.ptr
  }
  pub fn context<'a>(&self) -> &'a ExecutingContext {
    assert!(!self.context.is_null(), "Context PTR must not be null");
    unsafe { &*self.context }
  }
  pub fn add_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &AddEventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    let callback_context_data = Box::new(EventCallbackContextData {
      executing_context_ptr: self.context().ptr,
      executing_context_method_pointer: self.context().method_pointer(),
      executing_context_meta_data: self.context().meta_data,
      executing_context_status: self.context().status,
      func: callback,
    });
    let callback_context_data_ptr = Box::into_raw(callback_context_data);
    let callback_context = Box::new(EventCallbackContext {
      callback: invoke_event_listener_callback,
      free_ptr: release_event_listener_callback,
      ptr: callback_context_data_ptr
    });
    let callback_context_ptr = Box::into_raw(callback_context);
    unsafe {
      ((*self.method_pointer).add_event_listener)(self.ptr(), CString::new(type_).unwrap().as_ptr(), callback_context_ptr, options, exception_state.ptr);
    };
    if exception_state.has_exception() {
      unsafe {
        let _ = Box::from_raw(callback_context_ptr);
        let _ = Box::from_raw(callback_context_data_ptr);
      }
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn remove_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &EventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    let callback_context_data = Box::new(EventCallbackContextData {
      executing_context_ptr: self.context().ptr,
      executing_context_method_pointer: self.context().method_pointer(),
      executing_context_meta_data: self.context().meta_data,
      executing_context_status: self.context().status,
      func: callback,
    });
    let callback_context_data_ptr = Box::into_raw(callback_context_data);
    let callback_context = Box::new(EventCallbackContext {
      callback: invoke_event_listener_callback,
      free_ptr: release_event_listener_callback,
      ptr: callback_context_data_ptr
    });
    let callback_context_ptr = Box::into_raw(callback_context);
    unsafe {
      ((*self.method_pointer).remove_event_listener)(self.ptr(), CString::new(type_).unwrap().as_ptr(), callback_context_ptr, options, exception_state.ptr);
    };
    if exception_state.has_exception() {
      unsafe {
        let _ = Box::from_raw(callback_context_ptr);
        let _ = Box::from_raw(callback_context_data_ptr);
      }
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn dispatch_event(&self, event: &Event, exception_state: &ExceptionState) -> Result<bool, String> {
    let value = unsafe {
      ((*self.method_pointer).dispatch_event)(self.ptr(), event.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(value != 0)
  }
  pub fn as_screen(&self) -> Result<Screen, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::Screen)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the Screen type.");
    }
    Ok(Screen::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const ScreenRustMethods, raw_ptr.status))
  }
  pub fn as_window(&self) -> Result<Window, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::Window)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the Window type.");
    }
    Ok(Window::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const WindowRustMethods, raw_ptr.status))
  }
  pub fn as_node(&self) -> Result<Node, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::Node)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the Node type.");
    }
    Ok(Node::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const NodeRustMethods, raw_ptr.status))
  }
  pub fn as_character_data(&self) -> Result<CharacterData, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::CharacterData)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the CharacterData type.");
    }
    Ok(CharacterData::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const CharacterDataRustMethods, raw_ptr.status))
  }
  pub fn as_comment(&self) -> Result<Comment, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::Comment)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the Comment type.");
    }
    Ok(Comment::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const CommentRustMethods, raw_ptr.status))
  }
  pub fn as_text(&self) -> Result<Text, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::Text)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the Text type.");
    }
    Ok(Text::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const TextRustMethods, raw_ptr.status))
  }
  pub fn as_document(&self) -> Result<Document, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::Document)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the Document type.");
    }
    Ok(Document::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const DocumentRustMethods, raw_ptr.status))
  }
  pub fn as_document_fragment(&self) -> Result<DocumentFragment, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::DocumentFragment)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the DocumentFragment type.");
    }
    Ok(DocumentFragment::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const DocumentFragmentRustMethods, raw_ptr.status))
  }
  pub fn as_element(&self) -> Result<Element, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::Element)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the Element type.");
    }
    Ok(Element::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const ElementRustMethods, raw_ptr.status))
  }
  pub fn as_html_element(&self) -> Result<HTMLElement, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::HTMLElement)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the HTMLElement type.");
    }
    Ok(HTMLElement::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const HTMLElementRustMethods, raw_ptr.status))
  }
  pub fn as_html_script_element(&self) -> Result<HTMLScriptElement, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::HTMLScriptElement)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the HTMLScriptElement type.");
    }
    Ok(HTMLScriptElement::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const HTMLScriptElementRustMethods, raw_ptr.status))
  }
  pub fn as_html_head_element(&self) -> Result<HTMLHeadElement, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::HTMLHeadElement)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the HTMLHeadElement type.");
    }
    Ok(HTMLHeadElement::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const HTMLHeadElementRustMethods, raw_ptr.status))
  }
  pub fn as_html_image_element(&self) -> Result<HTMLImageElement, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::HTMLImageElement)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the HTMLImageElement type.");
    }
    Ok(HTMLImageElement::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const HTMLImageElementRustMethods, raw_ptr.status))
  }
  pub fn as_image(&self) -> Result<Image, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::Image)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the Image type.");
    }
    Ok(Image::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const ImageRustMethods, raw_ptr.status))
  }
  pub fn as_html_canvas_element(&self) -> Result<HTMLCanvasElement, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::HTMLCanvasElement)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the HTMLCanvasElement type.");
    }
    Ok(HTMLCanvasElement::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const HTMLCanvasElementRustMethods, raw_ptr.status))
  }
  pub fn as_html_html_element(&self) -> Result<HTMLHtmlElement, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::HTMLHtmlElement)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the HTMLHtmlElement type.");
    }
    Ok(HTMLHtmlElement::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const HTMLHtmlElementRustMethods, raw_ptr.status))
  }
  pub fn as_html_body_element(&self) -> Result<HTMLBodyElement, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::HTMLBodyElement)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the HTMLBodyElement type.");
    }
    Ok(HTMLBodyElement::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const HTMLBodyElementRustMethods, raw_ptr.status))
  }
  pub fn as_html_div_element(&self) -> Result<HTMLDivElement, &str> {
    let raw_ptr = unsafe {
      assert!(!(*((*self).status)).disposed, "The underline C++ impl of this ptr({:?}) had been disposed", (self.method_pointer));
      ((*self.method_pointer).dynamic_to)(self.ptr, EventTargetType::HTMLDivElement)
    };
    if (raw_ptr.value == std::ptr::null()) {
      return Err("The type value of EventTarget does not belong to the HTMLDivElement type.");
    }
    Ok(HTMLDivElement::initialize(raw_ptr.value, self.context, raw_ptr.method_pointer as *const HTMLDivElementRustMethods, raw_ptr.status))
  }
}
impl Drop for EventTarget {
  fn drop(&mut self) {
    unsafe {
      ((*self.method_pointer).release)(self.ptr());
    }
  }
}
pub trait EventTargetMethods {
  fn add_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &AddEventListenerOptions, exception_state: &ExceptionState) -> Result<(), String>;
  fn remove_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &EventListenerOptions, exception_state: &ExceptionState) -> Result<(), String>;
  fn dispatch_event(&self, event: &Event, exception_state: &ExceptionState) -> Result<bool, String>;
  fn as_event_target(&self) -> &EventTarget;
}
impl EventTargetMethods for EventTarget {
  fn add_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &AddEventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.add_event_listener(type_, callback, options, exception_state)
  }
  fn remove_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &EventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.remove_event_listener(type_, callback, options, exception_state)
  }
  fn dispatch_event(&self, event: &Event, exception_state: &ExceptionState) -> Result<bool, String> {
    self.dispatch_event(event, exception_state)
  }
  fn as_event_target(&self) -> &EventTarget {
    self
  }
}
impl ExecutingContext {
  pub fn create_event_target(&self, exception_state: &ExceptionState) -> Result<EventTarget, String> {
    let new_obj = unsafe {
      ((*self.method_pointer()).create_event_target)(self.ptr, exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self));
    }
    return Ok(EventTarget::initialize(new_obj.value, self, new_obj.method_pointer, new_obj.status));
  }
}
