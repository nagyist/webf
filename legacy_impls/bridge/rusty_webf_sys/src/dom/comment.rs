// Generated by WebF TSDL, don't edit this file directly.
// Generate command: node scripts/generate_binding_code.js
/*
* Copyright (C) 2022-present The WebF authors. All rights reserved.
*/
use std::ffi::*;
use crate::*;
#[repr(C)]
pub struct CommentRustMethods {
  pub version: c_double,
  pub character_data: CharacterDataRustMethods,
}
pub struct Comment {
  pub character_data: CharacterData,
  method_pointer: *const CommentRustMethods,
}
impl Comment {
  pub fn initialize(ptr: *const OpaquePtr, context: *const ExecutingContext, method_pointer: *const CommentRustMethods, status: *const RustValueStatus) -> Comment {
    unsafe {
      Comment {
        character_data: CharacterData::initialize(
          ptr,
          context,
          &(method_pointer).as_ref().unwrap().character_data,
          status,
        ),
        method_pointer,
      }
    }
  }
  pub fn ptr(&self) -> *const OpaquePtr {
    self.character_data.ptr()
  }
  pub fn context<'a>(&self) -> &'a ExecutingContext {
    self.character_data.context()
  }
}
pub trait CommentMethods: CharacterDataMethods {
  fn as_comment(&self) -> &Comment;
}
impl CommentMethods for Comment {
  fn as_comment(&self) -> &Comment {
    self
  }
}
impl CharacterDataMethods for Comment {
  fn data(&self) -> String {
    self.character_data.data()
  }
  fn set_data(&self, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.character_data.set_data(value, exception_state)
  }
  fn length(&self) -> i64 {
    self.character_data.length()
  }
  fn as_character_data(&self) -> &CharacterData {
    &self.character_data
  }
}
impl NodeMethods for Comment {
  fn element_node(&self) -> f64 {
    self.character_data.node.element_node()
  }
  fn attribute_node(&self) -> f64 {
    self.character_data.node.attribute_node()
  }
  fn text_node(&self) -> f64 {
    self.character_data.node.text_node()
  }
  fn comment_node(&self) -> f64 {
    self.character_data.node.comment_node()
  }
  fn document_node(&self) -> f64 {
    self.character_data.node.document_node()
  }
  fn document_type_node(&self) -> f64 {
    self.character_data.node.document_type_node()
  }
  fn document_fragment_node(&self) -> f64 {
    self.character_data.node.document_fragment_node()
  }
  fn node_type(&self) -> f64 {
    self.character_data.node.node_type()
  }
  fn node_name(&self) -> String {
    self.character_data.node.node_name()
  }
  fn child_nodes(&self) -> NodeList {
    self.character_data.node.child_nodes()
  }
  fn first_child(&self) -> Node {
    self.character_data.node.first_child()
  }
  fn is_connected(&self) -> bool {
    self.character_data.node.is_connected()
  }
  fn last_child(&self) -> Node {
    self.character_data.node.last_child()
  }
  fn next_sibling(&self) -> Node {
    self.character_data.node.next_sibling()
  }
  fn owner_document(&self) -> Document {
    self.character_data.node.owner_document()
  }
  fn parent_element(&self) -> Element {
    self.character_data.node.parent_element()
  }
  fn parent_node(&self) -> Node {
    self.character_data.node.parent_node()
  }
  fn previous_sibling(&self) -> Node {
    self.character_data.node.previous_sibling()
  }
  fn has_child_nodes(&self, exception_state: &ExceptionState) -> Result<bool, String> {
    self.character_data.node.has_child_nodes(exception_state)
  }
  fn append_child(&self, new_node: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.character_data.node.append_child(new_node, exception_state)
  }
  fn clone_node(&self, deep: bool, exception_state: &ExceptionState) -> Result<Node, String> {
    self.character_data.node.clone_node(deep, exception_state)
  }
  fn contains(&self, other: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.character_data.node.contains(other, exception_state)
  }
  fn insert_before(&self, new_child: &Node, ref_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.character_data.node.insert_before(new_child, ref_child, exception_state)
  }
  fn is_equal_node(&self, other_node: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.character_data.node.is_equal_node(other_node, exception_state)
  }
  fn is_same_node(&self, other_node: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.character_data.node.is_same_node(other_node, exception_state)
  }
  fn remove_child(&self, old_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.character_data.node.remove_child(old_child, exception_state)
  }
  fn remove(&self, exception_state: &ExceptionState) -> Result<(), String> {
    self.character_data.node.remove(exception_state)
  }
  fn replace_child(&self, new_child: &Node, old_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.character_data.node.replace_child(new_child, old_child, exception_state)
  }
  fn as_node(&self) -> &Node {
    &self.character_data.node
  }
}
impl EventTargetMethods for Comment {
  fn add_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &AddEventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.character_data.node.event_target.add_event_listener(type_, callback, options, exception_state)
  }
  fn remove_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &EventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.character_data.node.event_target.remove_event_listener(type_, callback, options, exception_state)
  }
  fn dispatch_event(&self, event: &Event, exception_state: &ExceptionState) -> Result<bool, String> {
    self.character_data.node.event_target.dispatch_event(event, exception_state)
  }
  fn as_event_target(&self) -> &EventTarget {
    &self.character_data.node.event_target
  }
}
impl ExecutingContext {
}
