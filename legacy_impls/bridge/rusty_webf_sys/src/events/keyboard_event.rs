// Generated by WebF TSDL, don't edit this file directly.
// Generate command: node scripts/generate_binding_code.js
/*
* Copyright (C) 2022-present The WebF authors. All rights reserved.
*/
use std::ffi::*;
use crate::*;
#[repr(C)]
pub struct KeyboardEventRustMethods {
  pub version: c_double,
  pub ui_event: UIEventRustMethods,
  pub alt_key: extern "C" fn(*const OpaquePtr) -> i32,
  pub char_code: extern "C" fn(*const OpaquePtr) -> c_double,
  pub code: extern "C" fn(*const OpaquePtr) -> AtomicStringRef,
  pub ctrl_key: extern "C" fn(*const OpaquePtr) -> i32,
  pub is_composing: extern "C" fn(*const OpaquePtr) -> i32,
  pub key: extern "C" fn(*const OpaquePtr) -> AtomicStringRef,
  pub key_code: extern "C" fn(*const OpaquePtr) -> c_double,
  pub location: extern "C" fn(*const OpaquePtr) -> c_double,
  pub meta_key: extern "C" fn(*const OpaquePtr) -> i32,
  pub repeat: extern "C" fn(*const OpaquePtr) -> i32,
  pub shift_key: extern "C" fn(*const OpaquePtr) -> i32,
  pub dom_key_location_left: extern "C" fn(*const OpaquePtr) -> c_double,
  pub dom_key_location_numpad: extern "C" fn(*const OpaquePtr) -> c_double,
  pub dom_key_location_right: extern "C" fn(*const OpaquePtr) -> c_double,
  pub dom_key_location_standard: extern "C" fn(*const OpaquePtr) -> c_double,
}
pub struct KeyboardEvent {
  pub ui_event: UIEvent,
  method_pointer: *const KeyboardEventRustMethods,
}
impl KeyboardEvent {
  pub fn initialize(ptr: *const OpaquePtr, context: *const ExecutingContext, method_pointer: *const KeyboardEventRustMethods, status: *const RustValueStatus) -> KeyboardEvent {
    unsafe {
      KeyboardEvent {
        ui_event: UIEvent::initialize(
          ptr,
          context,
          &(method_pointer).as_ref().unwrap().ui_event,
          status,
        ),
        method_pointer,
      }
    }
  }
  pub fn ptr(&self) -> *const OpaquePtr {
    self.ui_event.ptr()
  }
  pub fn context<'a>(&self) -> &'a ExecutingContext {
    self.ui_event.context()
  }
  pub fn alt_key(&self) -> bool {
    let value = unsafe {
      ((*self.method_pointer).alt_key)(self.ptr())
    };
    value != 0
  }
  pub fn char_code(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).char_code)(self.ptr())
    };
    value
  }
  pub fn code(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).code)(self.ptr())
    };
    value.to_string()
  }
  pub fn ctrl_key(&self) -> bool {
    let value = unsafe {
      ((*self.method_pointer).ctrl_key)(self.ptr())
    };
    value != 0
  }
  pub fn is_composing(&self) -> bool {
    let value = unsafe {
      ((*self.method_pointer).is_composing)(self.ptr())
    };
    value != 0
  }
  pub fn key(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).key)(self.ptr())
    };
    value.to_string()
  }
  pub fn key_code(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).key_code)(self.ptr())
    };
    value
  }
  pub fn location(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).location)(self.ptr())
    };
    value
  }
  pub fn meta_key(&self) -> bool {
    let value = unsafe {
      ((*self.method_pointer).meta_key)(self.ptr())
    };
    value != 0
  }
  pub fn repeat(&self) -> bool {
    let value = unsafe {
      ((*self.method_pointer).repeat)(self.ptr())
    };
    value != 0
  }
  pub fn shift_key(&self) -> bool {
    let value = unsafe {
      ((*self.method_pointer).shift_key)(self.ptr())
    };
    value != 0
  }
  pub fn dom_key_location_left(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).dom_key_location_left)(self.ptr())
    };
    value
  }
  pub fn dom_key_location_numpad(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).dom_key_location_numpad)(self.ptr())
    };
    value
  }
  pub fn dom_key_location_right(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).dom_key_location_right)(self.ptr())
    };
    value
  }
  pub fn dom_key_location_standard(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).dom_key_location_standard)(self.ptr())
    };
    value
  }
}
pub trait KeyboardEventMethods: UIEventMethods {
  fn alt_key(&self) -> bool;
  fn char_code(&self) -> f64;
  fn code(&self) -> String;
  fn ctrl_key(&self) -> bool;
  fn is_composing(&self) -> bool;
  fn key(&self) -> String;
  fn key_code(&self) -> f64;
  fn location(&self) -> f64;
  fn meta_key(&self) -> bool;
  fn repeat(&self) -> bool;
  fn shift_key(&self) -> bool;
  fn dom_key_location_left(&self) -> f64;
  fn dom_key_location_numpad(&self) -> f64;
  fn dom_key_location_right(&self) -> f64;
  fn dom_key_location_standard(&self) -> f64;
  fn as_keyboard_event(&self) -> &KeyboardEvent;
}
impl KeyboardEventMethods for KeyboardEvent {
  fn alt_key(&self) -> bool {
    self.alt_key()
  }
  fn char_code(&self) -> f64 {
    self.char_code()
  }
  fn code(&self) -> String {
    self.code()
  }
  fn ctrl_key(&self) -> bool {
    self.ctrl_key()
  }
  fn is_composing(&self) -> bool {
    self.is_composing()
  }
  fn key(&self) -> String {
    self.key()
  }
  fn key_code(&self) -> f64 {
    self.key_code()
  }
  fn location(&self) -> f64 {
    self.location()
  }
  fn meta_key(&self) -> bool {
    self.meta_key()
  }
  fn repeat(&self) -> bool {
    self.repeat()
  }
  fn shift_key(&self) -> bool {
    self.shift_key()
  }
  fn dom_key_location_left(&self) -> f64 {
    self.dom_key_location_left()
  }
  fn dom_key_location_numpad(&self) -> f64 {
    self.dom_key_location_numpad()
  }
  fn dom_key_location_right(&self) -> f64 {
    self.dom_key_location_right()
  }
  fn dom_key_location_standard(&self) -> f64 {
    self.dom_key_location_standard()
  }
  fn as_keyboard_event(&self) -> &KeyboardEvent {
    self
  }
}
impl UIEventMethods for KeyboardEvent {
  fn detail(&self) -> f64 {
    self.ui_event.detail()
  }
  fn view(&self) -> Window {
    self.ui_event.view()
  }
  fn which(&self) -> f64 {
    self.ui_event.which()
  }
  fn as_ui_event(&self) -> &UIEvent {
    &self.ui_event
  }
}
impl EventMethods for KeyboardEvent {
  fn bubbles(&self) -> bool {
    self.ui_event.event.bubbles()
  }
  fn cancel_bubble(&self) -> bool {
    self.ui_event.event.cancel_bubble()
  }
  fn set_cancel_bubble(&self, value: bool, exception_state: &ExceptionState) -> Result<(), String> {
    self.ui_event.event.set_cancel_bubble(value, exception_state)
  }
  fn cancelable(&self) -> bool {
    self.ui_event.event.cancelable()
  }
  fn current_target(&self) -> EventTarget {
    self.ui_event.event.current_target()
  }
  fn default_prevented(&self) -> bool {
    self.ui_event.event.default_prevented()
  }
  fn src_element(&self) -> EventTarget {
    self.ui_event.event.src_element()
  }
  fn target(&self) -> EventTarget {
    self.ui_event.event.target()
  }
  fn is_trusted(&self) -> bool {
    self.ui_event.event.is_trusted()
  }
  fn time_stamp(&self) -> f64 {
    self.ui_event.event.time_stamp()
  }
  fn type_(&self) -> String {
    self.ui_event.event.type_()
  }
  fn init_event(&self, type_: &str, bubbles: bool, cancelable: bool, exception_state: &ExceptionState) -> Result<(), String> {
    self.ui_event.event.init_event(type_, bubbles, cancelable, exception_state)
  }
  fn prevent_default(&self, exception_state: &ExceptionState) -> Result<(), String> {
    self.ui_event.event.prevent_default(exception_state)
  }
  fn stop_immediate_propagation(&self, exception_state: &ExceptionState) -> Result<(), String> {
    self.ui_event.event.stop_immediate_propagation(exception_state)
  }
  fn stop_propagation(&self, exception_state: &ExceptionState) -> Result<(), String> {
    self.ui_event.event.stop_propagation(exception_state)
  }
  fn as_event(&self) -> &Event {
    &self.ui_event.event
  }
}
impl ExecutingContext {
  pub fn create_keyboard_event(&self, event_type: &str, exception_state: &ExceptionState) -> Result<KeyboardEvent, String> {
    let event_type_c_string = CString::new(event_type).unwrap();
    let new_event = unsafe {
      ((*self.method_pointer()).create_keyboard_event)(self.ptr, event_type_c_string.as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self));
    }
    return Ok(KeyboardEvent::initialize(new_event.value, self, new_event.method_pointer, new_event.status));
  }
  pub fn create_keyboard_event_with_options(&self, event_type: &str, options: &KeyboardEventInit,  exception_state: &ExceptionState) -> Result<KeyboardEvent, String> {
    let event_type_c_string = CString::new(event_type).unwrap();
    let new_event = unsafe {
      ((*self.method_pointer()).create_keyboard_event_with_options)(self.ptr, event_type_c_string.as_ptr(), options, exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self));
    }
    return Ok(KeyboardEvent::initialize(new_event.value, self, new_event.method_pointer, new_event.status));
  }
}
